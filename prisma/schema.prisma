// Definição de migrações Prisma para o sistema
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS PRINCIPAIS DO SISTEMA ====================

// Enum para status comum entre entidades
enum Status {
  ACTIVE
  INACTIVE
}

// Enum para tipos de usuário
enum UserType {
  PESSOA_FISICA
  PESSOA_JURIDICA
}

// Enum para níveis educacionais
enum EducationLevel {
  ENSINO_FUNDAMENTAL_INCOMPLETO
  ENSINO_FUNDAMENTAL_COMPLETO
  ENSINO_MEDIO_INCOMPLETO
  ENSINO_MEDIO_COMPLETO
  ENSINO_SUPERIOR_INCOMPLETO
  ENSINO_SUPERIOR_COMPLETO
  POS_GRADUACAO
  MESTRADO
  DOUTORADO
}

// Enum para gênero
enum Gender {
  MASCULINO
  FEMININO
  OUTRO
  NAO_INFORMADO
}

// Enum para estado civil
enum MaritalStatus {
  SOLTEIRO
  CASADO
  DIVORCIADO
  VIUVO
  UNIAO_ESTAVEL
  OUTRO
}

// Enum para intervalos de cobrança
enum BillingInterval {
  MONTHLY
  QUARTERLY
  SEMIANNUAL
  ANNUAL
}

// Enum para status de assinatura
enum SubscriptionStatus {
  ACTIVE           // Assinatura ativa
  CANCELED         // Cancelada pelo usuário ou admin
  PENDING          // Aguardando primeiro pagamento
  PAYMENT_FAILED   // Falha no pagamento
  PAST_DUE         // Pagamento atrasado
  TRIAL            // Em período de teste
  EXPIRED          // Expirada sem renovação
  ON_HOLD          // Suspensa temporariamente
}

// Enum para tipos de métodos de pagamento
enum PaymentMethodType {
  CREDIT_CARD      // Cartão de Crédito
  DEBIT_CARD       // Cartão de Débito
  PIX              // PIX
  BANK_SLIP        // Boleto Bancário
  BANK_TRANSFER    // Transferência Bancária
  MP_CHECKOUT      // Checkout do Mercado Pago
}

// Enum para bandeiras de cartão
enum CardBrand {
  VISA
  MASTERCARD
  AMEX
  ELO
  HIPERCARD
  DINERS
  DISCOVER
  JCB
  OTHER
}

// Enum para status de pagamento
enum PaymentStatus {
  PENDING           // Aguardando pagamento
  APPROVED          // Pagamento aprovado
  DECLINED          // Pagamento recusado
  IN_PROCESS        // Em processamento
  IN_MEDIATION      // Em mediação (disputa)
  REFUNDED          // Pagamento reembolsado
  PARTIALLY_REFUNDED // Parcialmente reembolsado
  CHARGED_BACK      // Estornado
  CANCELLED         // Cancelado
  REJECTED          // Rejeitado
  FAILED            // Falha no processamento
}

// Enum para status de registro pendente
enum PendingRegistrationStatus {
  WAITING_PAYMENT   // Aguardando pagamento
  PAYMENT_APPROVED  // Pagamento aprovado, pendente de conversão
  PAYMENT_FAILED    // Pagamento falhou
  CONVERTED         // Convertido em usuário
  EXPIRED           // Expirado/abandonado
}

// Enum para tipos de desconto
enum DiscountType {
  PERCENTAGE        // Desconto percentual (%)
  FIXED_AMOUNT      // Valor fixo (R$)
}

// Enum para status de cupom
enum CouponStatus {
  ACTIVE            // Cupom ativo
  INACTIVE          // Cupom inativo
  EXPIRED           // Cupom expirado
  USAGE_LIMIT_REACHED // Limite de uso atingido
}

// Tipo de liberação para módulos e aulas
enum ReleaseType {
  IMMEDIATE         // Liberação imediata
  FIXED_DATE        // Data específica
  DAYS_AFTER        // Dias após matrícula/conclusão da aula anterior
}

// Tipos de colaborador
enum CollaboratorType {
  PROFESSOR
  TUTOR
}

// Tipos de produto
enum ProductType {
  CURSO
  COMBO
  ASSINATURA
}

// Tipo de conteúdo específico da aula
enum ContentType {
  VIDEO               // Vídeo gravado
  LIBRARY             // Conteúdo da biblioteca
  UPLOAD              // Arquivo para upload (PDF, etc)
  EAD_PLAYER          // Player de vídeo da plataforma
  VIDEO_URL           // Link de vídeo externo (Youtube, etc)
  LIVE                // Aula ao vivo
  EAD_MEET            // Conferência
  PODCAST             // Áudio/Podcast
  EMBED               // Código incorporado
  HTML_EDITOR         // Editor HTML
  TEXT                // Texto formatado
  FILE                // Arquivo para download
  QUIZ                // Questionário/Quiz
}

// Status de publicação de conteúdo
enum PublishStatus {
  DRAFT              // Rascunho
  PUBLISHED          // Publicado
}

// Status de matrícula
enum EnrollmentStatus {
  ACTIVE             // Matrícula ativa
  COMPLETED          // Curso concluído
  EXPIRED            // Acesso expirado
  CANCELED           // Matrícula cancelada
  PENDING_PAYMENT    // Aguardando pagamento
}

// Enum para critérios de conclusão do curso
enum CompletionCriteria {
  EXAM_ONLY          // Apenas prova final
  INTERNSHIP_ONLY    // Apenas estágio
  EXAM_AND_INTERNSHIP // Ambos (prova e estágio)
  ATTENDANCE_ONLY    // Apenas presença/participação
  MODULE_COMPLETION  // Conclusão de todos os módulos
  CUSTOM             // Critério personalizado
}

// Enum para status do certificado
enum CertificateStatus {
  PENDING            // Pendente de emissão
  ISSUED             // Emitido
  REVOKED            // Revogado
  EXPIRED            // Expirado
}

// Enum para tipos de questão
enum QuestionType {
  MULTIPLA_ESCOLHA     // Múltipla escolha (apenas uma resposta correta)
  MULTIPLA_SELECAO     // Múltipla seleção (várias respostas corretas)
  VERDADEIRO_FALSO     // Verdadeiro ou falso
  DISSERTATIVA         // Questão dissertativa (resposta aberta)
  ORDENACAO            // Ordenação de itens
  ASSOCIACAO           // Associação de colunas
  COMPLETAR_LACUNAS    // Completar espaços em branco
  NUMERICA             // Resposta numérica
}

// Enum para nível de dificuldade da questão
enum DifficultyLevel {
  MUITO_FACIL
  FACIL
  MEDIO
  DIFICIL
  MUITO_DIFICIL
}

// Enum para tipo de liberação de prova
enum ExamReleaseType {
  IMMEDIATELY         // Liberação imediata após aulas anteriores
  SPECIFIC_DATE       // Data específica
  FLEXIBLE_PERIOD     // Período após concluir aula anterior
}

// Enum para ordem das questões
enum QuestionOrder {
  SEQUENTIAL          // Ordem sequencial fixa
  RANDOM              // Ordem aleatória
}

// Enum para níveis de experiência
enum ExperienceLevel {
  ESTAGIO
  JUNIOR
  PLENO
  SENIOR
  ESPECIALISTA
  GERENTE
  DIRETOR
}

// Enum para tipos de contratação
enum HiringType {
  CLT
  PJ
  ESTAGIO
  TEMPORARIO
  FREELANCER
}

// Enum para status da vaga
enum JobStatus {
  DRAFT               // Rascunho
  PENDING_APPROVAL    // Aguardando aprovação do recrutador
  REJECTED            // Rejeitada pelo recrutador
  PUBLISHED           // Publicada e ativa
  PAUSED              // Pausada temporariamente
  CLOSED              // Fechada (prazo expirou ou atingiu limite de candidaturas)
  FILLED              // Preenchida
  CANCELLED           // Cancelada
}

// Enum para status da candidatura
enum ApplicationStatus {
  SUBMITTED           // Enviada
  UNDER_REVIEW        // Em análise
  INTERVIEW_SCHEDULED // Entrevista agendada
  TECHNICAL_TEST      // Teste técnico
  FINAL_INTERVIEW     // Entrevista final
  OFFER_EXTENDED      // Proposta enviada
  HIRED               // Contratado
  REJECTED            // Rejeitado
  CANCELLED           // Cancelado pelo candidato
}

// ==================== MODELOS PRINCIPAIS DO SISTEMA ====================

// Modelo de papel/função do usuário
model Role {
  id          String   @id @default(uuid())
  name        String   @unique
  level       Int
  status      Int      @default(1)
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relacionamentos
  users       User[]

  @@map("roles")
}

// Modelo de usuário (comum para ambos os tipos)
model User {
  id            String       @id @default(uuid())
  email         String       @unique
  password      String
  userType      UserType
  matricula     String       @unique  // Formato: AD158KJ
  refreshToken  String?      @db.Text
  isActive      Boolean      @default(true)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  lastLogin     DateTime?
  
  // Relacionamento com Role
  roleId        String
  role          Role         @relation(fields: [roleId], references: [id])
  
  // Relacionamentos com informações específicas
  personalInfo  PersonalInfo?
  companyInfo   CompanyInfo?
  address       Address?

  // Relacionamentos financeiros
  subscriptions Subscription[]
  paymentCards  PaymentCard[]
  checkoutSessions CheckoutSession[]
  createdCoupons Coupon[]     @relation("couponCreator")
  couponUsageHistory CouponUsageHistory[]

  // Relacionamentos AVA
  coordinatedCourses Course[]           @relation("courseCoordinator")
  coursesAsCollaborator CourseProfessor[]
  teachingLessons Lesson[]
  enrollments Enrollment[]
  examAnswers ExamAnswer[]
  
  // Relacionamentos banco de questões
  createdQuestions Question[]        @relation("questionCreator")
  updatedQuestions Question[]        @relation("questionUpdater")
  createdQuestionBanks QuestionBank[] @relation("questionBankCreator")
  updatedQuestionBanks QuestionBank[] @relation("questionBankUpdater")
  studentAnswers QuestionAnswer[]

  // Relacionamentos provas
  createdExams      Exam[]      @relation("examCreator")
  updatedExams      Exam[]      @relation("examUpdater")
  examAttempts      ExamAttempt[]
  grades            StudentGrade[]
  attemptAnswers    ExamAttemptAnswer[]
  
  // Relacionamentos notificações
  notifications     UserNotification[]
  
  // Relacionamentos certificados
  certificateTemplatesCreated CertificateTemplate[]
  certificateTemplatesUpdated CertificateTemplate[] @relation("certificateTemplateUpdater")
  certificatesIssued Certificate[] @relation("certificateIssuer")

  // Relacionamentos sistema de vagas
  publishedJobs     JobOffer[]
  reviewedJobs      JobOffer[]        @relation("jobReviewer")
  jobRevisions      JobRevision[]
  resume            Resume?
  jobApplications   JobApplication[]
  statusChanges     ApplicationStatusHistory[]
  createdInterviews JobInterview[]

  @@map("users")
}

// Modelo para informações de pessoa física
model PersonalInfo {
  id              String    @id @default(uuid())
  name            String
  cpf             String    @unique
  rg              String?
  birthDate       DateTime
  gender          Gender
  phone           String
  companyName     String?   // Empresa onde trabalha (opcional)
  maritalStatus   MaritalStatus?
  educationLevel  EducationLevel? // Nível educacional
  
  // Relacionamento com usuário (1:1)
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("personal_info")
}

// Modelo para informações de pessoa jurídica
model CompanyInfo {
  id              String    @id @default(uuid())
  companyName     String    // Nome da empresa
  tradeName       String    // Nome fantasia
  legalName       String    // Razão social
  cnpj            String    @unique
  phone           String
  website         String?
  logoUrl         String?   // URL da logo
  logoFilename    String?   // Nome do arquivo da logo
  
  // Relacionamento com usuário (1:1)
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relacionamento com pré-registros
  pendingRegistrations PendingRegistration[]

  @@map("company_info")
}

// Modelo para endereço (usado tanto por pessoa física quanto jurídica)
model Address {
  id              String    @id @default(uuid())
  zipCode         String    // CEP
  street          String    // Logradouro
  number          String
  neighborhood    String    // Bairro
  complement      String?
  city            String
  state           String
  country         String    @default("Brasil")
  
  // Relacionamento com usuário (1:1)
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relacionamento com pré-registros
  pendingRegistrationId String? @unique
  pendingRegistration   PendingRegistration? @relation(fields: [pendingRegistrationId], references: [id], onDelete: Cascade)

  @@map("addresses")
}

// ==================== MODELOS DE PAGAMENTO ====================

// Modelo para planos de assinatura
model SubscriptionPlan {
  id              String   @id @default(uuid())
  name            String   @unique // Inicial, Intermediário, Avançado, Destaque
  price           Decimal  @db.Decimal(10, 2) // Preço mensal
  description     String?  @db.Text
  features        Json     // Características do plano como JSON
  interval        BillingInterval @default(MONTHLY)
  intervalCount   Int      @default(1) // Quantas unidades do intervalo
  trialDays       Int?     // Dias de teste gratuito, se aplicável
  isActive        Boolean  @default(true)
  isPopular       Boolean  @default(false) // Para marcar planos como "Mais popular"
  mpProductId     String?  // ID do produto no Mercado Pago (se aplicável)
  
  // Campos para sistema de vagas
  maxJobOffers      Int?      @default(0) // Número máximo de vagas ativas
  featuredJobOffers Int?      @default(0) // Número de vagas em destaque
  confidentialOffers Boolean   @default(false) // Permite vagas confidenciais
  resumeAccess      Boolean   @default(true) // Acesso à base de currículos
  allowPremiumFilters Boolean  @default(false) // Filtros avançados de busca
  
  // Campos de auditoria
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relacionamentos
  subscriptions   Subscription[]
  checkoutSessions CheckoutSession[]
  pendingRegistrations PendingRegistration[]
  allowedCoupons  CouponPlanRestriction[] // Cupons permitidos para este plano

  @@map("subscription_plans")
}

// Modelo para métodos de pagamento disponíveis
model PaymentMethod {
  id              String   @id @default(uuid())
  type            PaymentMethodType
  name            String   // Nome amigável: "Cartão de Crédito", "PIX", etc.
  description     String?
  isActive        Boolean  @default(true)
  mpPaymentTypeId String?  // ID do tipo de pagamento no Mercado Pago
  mpPaymentMethodId String? // ID do método de pagamento no Mercado Pago
  processingFee   Decimal? @db.Decimal(10, 2) // Taxa de processamento (%)
  fixedFee        Decimal? @db.Decimal(10, 2) // Taxa fixa (R$)
  requiredFields  Json?    // Campos requeridos para este método
  
  // Campos de auditoria
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relacionamentos
  subscriptions   Subscription[]
  checkoutSessions CheckoutSession[]

  @@map("payment_methods")
}

// Modelo para cartões de pagamento salvos
model PaymentCard {
  id              String    @id @default(uuid())
  cardHolderName  String    // Nome no cartão
  last4Digits     String    // Últimos 4 dígitos do cartão
  brand           CardBrand // Bandeira do cartão
  expiryMonth     Int       // Mês de expiração
  expiryYear      Int       // Ano de expiração
  tokenId         String?   // Token do cartão no Mercado Pago
  cardId          String?   // ID do cartão no Mercado Pago
  isDefault       Boolean   @default(false) // Indica se é o cartão padrão
  isActive        Boolean   @default(true)  // Indica se o cartão está ativo
  
  // Campos de auditoria
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relacionamento com usuário
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relacionamentos
  subscriptions   Subscription[]

  @@map("payment_cards")
}

// Modelo para assinaturas
model Subscription {
  id                String            @id @default(uuid())
  status            SubscriptionStatus @default(PENDING)
  startDate         DateTime
  endDate           DateTime?
  nextBillingDate   DateTime          // Data da próxima cobrança
  canceledAt        DateTime?         // Data de cancelamento
  cancelReason      String?           // Motivo do cancelamento
  isPaused          Boolean           @default(false)
  pausedAt          DateTime?         // Data de pausa
  
  // Contadores de uso para sistema de vagas
  usedJobOffers     Int       @default(0) // Vagas utilizadas
  usedFeaturedOffers Int      @default(0) // Vagas em destaque utilizadas
  
  // Dados do Mercado Pago
  mpSubscriptionId  String?           // ID da assinatura no Mercado Pago
  mpPreapprovalId   String?           // ID de pré-aprovação no Mercado Pago
  mpMerchantOrderId String?           // ID do pedido no Mercado Pago
  
  // Outros dados
  currentPeriodStart DateTime         // Início do período atual
  currentPeriodEnd   DateTime         // Fim do período atual
  renewalFailures    Int              @default(0) // Falhas de renovação
  renewalAttemptDate DateTime?        // Última tentativa de renovação
  metadataJson       Json?            // Metadados adicionais
  
  // Dados de desconto e cupom
  couponId          String?           // ID do cupom utilizado
  coupon            Coupon?           @relation(fields: [couponId], references: [id])
  discountAmount    Decimal?          @db.Decimal(10, 2) // Valor do desconto
  originalPrice     Decimal?          @db.Decimal(10, 2) // Preço original antes do desconto
  
  // Campos de auditoria
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  // Relacionamentos
  userId            String
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId            String
  plan              SubscriptionPlan  @relation(fields: [planId], references: [id])
  paymentMethodId   String
  paymentMethod     PaymentMethod     @relation(fields: [paymentMethodId], references: [id])
  paymentCardId     String?
  paymentCard       PaymentCard?      @relation(fields: [paymentCardId], references: [id])
  payments          Payment[]
  checkoutSessionId String?           @unique
  checkoutSession   CheckoutSession?  @relation(fields: [checkoutSessionId], references: [id])
  couponUsageHistory CouponUsageHistory[]

  @@map("subscriptions")
  @@index([mpSubscriptionId])
  @@index([mpPreapprovalId])
  @@index([couponId])
}

// Modelo para pagamentos
model Payment {
  id              String        @id @default(uuid())
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("BRL")
  status          PaymentStatus @default(PENDING)
  paymentDate     DateTime
  description     String?
  
  // Dados do Mercado Pago
  mpPaymentId     String?       // ID do pagamento no Mercado Pago
  mpExternalReference String?   // Referência externa no Mercado Pago
  mpPreferenceId  String?       // ID da preferência no Mercado Pago
  mpMerchantOrderId String?     // ID do pedido no Mercado Pago
  mpPaymentMethodId String?     // ID do método de pagamento usado
  mpPaymentTypeId String?       // ID do tipo de pagamento usado
  mpStatus        String?       // Status original do Mercado Pago
  mpStatusDetail  String?       // Detalhes do status do Mercado Pago
  
  // Outros dados do pagamento
  gatewayResponse Json?         // Resposta completa do gateway
  notificationData Json?        // Dados da notificação recebida
  invoiceUrl      String?       // URL do comprovante/fatura
  receiptUrl      String?       // URL do recibo
  failureReason   String?       // Razão da falha, se houver
  
  // Dados de desconto e cupom
  discountAmount  Decimal?      @db.Decimal(10, 2) // Valor do desconto aplicado
  originalAmount  Decimal?      @db.Decimal(10, 2) // Valor original antes do desconto
  couponCode      String?       // Código do cupom usado (para histórico)
  
  // Controle e auditoria
  attemptCount    Int           @default(1) // Número de tentativas de cobrança
  lastAttempt     DateTime?     // Data da última tentativa
  refundedAt      DateTime?     // Data do reembolso, se houver
  refundAmount    Decimal?      @db.Decimal(10, 2) // Valor do reembolso
  refundReason    String?       // Motivo do reembolso
  
  // Campos de auditoria
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relacionamento com assinatura
  subscriptionId  String
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@map("payments")
  @@index([mpPaymentId])
  @@index([mpExternalReference])
  @@index([couponCode])
}

// Modelo para sessões de checkout
model CheckoutSession {
  id              String    @id @default(uuid())
  status          String    @default("pending") // pending, completed, expired, failed
  expiresAt       DateTime  // Quando a sessão expira
  
  // Dados do Mercado Pago
  mpPreferenceId  String?   // ID da preferência no Mercado Pago
  mpCheckoutUrl   String?   // URL de checkout do Mercado Pago
  mpInitPoint     String?   // Ponto de início do checkout do Mercado Pago
  mpSandboxInitPoint String? // Ponto de início do sandbox
  
  // Dados de desconto e cupom
  couponId        String?
  coupon          Coupon?   @relation(fields: [couponId], references: [id])
  discountAmount  Decimal?  @db.Decimal(10, 2) // Valor do desconto aplicado
  originalPrice   Decimal?  @db.Decimal(10, 2) // Preço original antes do desconto
  
  // Outros dados
  successUrl      String?   // URL de redirecionamento em caso de sucesso
  cancelUrl       String?   // URL de redirecionamento em caso de cancelamento
  callbackUrl     String?   // URL de callback
  metadataJson    Json?     // Metadados adicionais
  
  // Relacionamentos
  planId          String
  plan            SubscriptionPlan @relation(fields: [planId], references: [id])
  paymentMethodId String
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  userId          String?
  user            User?       @relation(fields: [userId], references: [id])
  subscription    Subscription?
  pendingRegistrationId String? @unique
  pendingRegistration   PendingRegistration? @relation(fields: [pendingRegistrationId], references: [id])
  couponUsageHistory CouponUsageHistory[]
  
  // Campos de auditoria
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("checkout_sessions")
  @@index([mpPreferenceId])
  @@index([couponId])
}

// Modelo para registros pendentes (usuários anônimos em processo de compra)
model PendingRegistration {
  id              String    @id @default(uuid())
  email           String    @unique  // Email usado durante o processo
  hashedPassword  String    // Senha hasheada para usar na criação do usuário
  userType        UserType  @default(PESSOA_JURIDICA) // Normalmente será PESSOA_JURIDICA
  status          PendingRegistrationStatus @default(WAITING_PAYMENT)
  
  // Dados de empresa
  companyName     String    // Nome da empresa
  tradeName       String    // Nome fantasia
  legalName       String    // Razão social
  cnpj            String    @unique // CNPJ da empresa
  phone           String    // Telefone de contato
  website         String?   // Website
  
  // Dados de contato
  contactName     String    // Nome do contato
  contactEmail    String    // Email do contato
  contactPhone    String    // Telefone do contato
  
  // Dados de desconto e cupom
  couponCode      String?   // Código do cupom usado (para histórico)
  discountAmount  Decimal?  @db.Decimal(10, 2) // Valor do desconto aplicado
  
  // Controle e rastreamento
  paymentApprovedAt DateTime? // Quando o pagamento foi aprovado
  paymentFailedAt   DateTime? // Quando o pagamento falhou
  convertedAt       DateTime? // Quando foi convertido em usuário
  convertedUserId   String?   // ID do usuário criado após conversão
  expiresAt         DateTime  // Quando o registro expira
  ipAddress         String?   // Endereço IP usado no registro
  userAgent         String?   // User agent do navegador
  
  // Relacionamentos
  planId           String    // Plano escolhido
  plan             SubscriptionPlan @relation(fields: [planId], references: [id])
  checkoutSession  CheckoutSession?
  address          Address?
  companyInfoId    String?
  companyInfo      CompanyInfo? @relation(fields: [companyInfoId], references: [id])
  
  // Campos de auditoria
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@map("pending_registrations")
  @@index([couponCode])
}

// Modelo para webhooks e notificações
model WebhookNotification {
  id              String    @id @default(uuid())
  source          String    // "mercadopago", etc
  eventType       String    // Tipo de evento
  eventId         String?   // ID do evento
  apiVersion      String?   // Versão da API
  liveMode        Boolean   @default(true) // Produção ou sandbox
  rawData         Json      // Dados brutos recebidos
  processedAt     DateTime? // Quando foi processado
  processStatus   String    @default("pending") // pending, success, failed
  error           String?   // Erro durante o processamento, se houver
  
  // Campos de auditoria
  createdAt       DateTime  @default(now())

  @@map("webhook_notifications")
  @@index([eventType, createdAt])
  @@index([eventId])
}

// ==================== MODELOS DE CUPONS DE DESCONTO ====================

// Modelo para cupons de desconto
model Coupon {
  id                String      @id @default(uuid())
  code              String      @unique // Código do cupom (ex: "BLACKFRIDAY10", "50OFF")
  name              String      // Nome amigável do cupom
  description       String?     @db.Text // Descrição do cupom
  discountType      DiscountType // Tipo de desconto (percentual ou valor fixo)
  discountValue     Decimal     @db.Decimal(10, 2) // Valor do desconto
  minPurchaseAmount Decimal?    @db.Decimal(10, 2) // Valor mínimo de compra
  maxDiscountAmount Decimal?    @db.Decimal(10, 2) // Valor máximo de desconto
  startDate         DateTime    // Data de início da validade
  endDate           DateTime    // Data de fim da validade
  usageLimit        Int?        // Limite total de usos
  perUserLimit      Int?        // Limite de usos por usuário
  status            CouponStatus @default(ACTIVE)
  customMessage     String?     @db.Text // Mensagem personalizada
  
  // Restrições e configurações para aplicação do cupom
  appliesToAllPlans Boolean     @default(true) // Se aplica a todos os planos
  requiresUserAccount Boolean   @default(true) // Requer conta de usuário
  userTypeLimitation UserType?  // Limita o tipo de usuário
  onlyFirstPurchase Boolean     @default(false) // Apenas primeira compra
  billingIntervals  Json?       // Intervalos de cobrança permitidos
  mpExternalId      String?     // ID externo do cupom no Mercado Pago
  
  // Estatísticas e rastreamento
  usageCount        Int         @default(0) // Contador de uso
  totalDiscountAmount Decimal   @default(0) @db.Decimal(10, 2) // Total de descontos concedidos
  
  // Auditoria
  createdById       String      // ID do usuário que criou o cupom
  createdBy         User        @relation("couponCreator", fields: [createdById], references: [id])
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  deactivatedAt     DateTime?   // Data de desativação
  
  // Relacionamentos
  subscriptions     Subscription[] // Assinaturas que usaram este cupom
  checkoutSessions  CheckoutSession[] // Checkout sessions que usaram este cupom
  couponUsageHistory CouponUsageHistory[] // Histórico de uso do cupom
  planRestrictions  CouponPlanRestriction[] // Restrições de plano para este cupom

  @@map("coupons")
  @@index([code])
  @@index([startDate, endDate])
  @@index([status])
  @@index([discountType])
  @@index([createdAt])
}

// Modelo para restrições de planos por cupom
model CouponPlanRestriction {
  id              String    @id @default(uuid())
  
  // Relacionamento com cupom
  couponId        String
  coupon          Coupon    @relation(fields: [couponId], references: [id], onDelete: Cascade)
  
  // Relacionamento com plano
  planId          String
  plan            SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime  @default(now())

  @@unique([couponId, planId])
  @@map("coupon_plan_restrictions")
}

// Modelo para histórico de uso de cupons
model CouponUsageHistory {
  id              String    @id @default(uuid())
  
  // Relacionamento com cupom
  couponId        String
  coupon          Coupon    @relation(fields: [couponId], references: [id])
  
  // Relacionamento com usuário
  userId          String
  user            User      @relation(fields: [userId], references: [id])
  
  // Dados do uso
  usedAt          DateTime  @default(now())
  discountAmount  Decimal   @db.Decimal(10, 2) // Valor do desconto aplicado
  originalAmount  Decimal   @db.Decimal(10, 2) // Valor original antes do desconto
  
  // Relacionamentos opcionais
  subscriptionId  String?
  subscription    Subscription? @relation(fields: [subscriptionId], references: [id])
  
  checkoutSessionId String?
  checkoutSession CheckoutSession? @relation(fields: [checkoutSessionId], references: [id])

  @@map("coupon_usage_history")
  @@index([couponId])
  @@index([userId])
  @@index([usedAt])
}

// Modelo para relatórios e métricas
model AnalyticsReport {
  id              String    @id @default(uuid())
  reportType      String    // Tipo de relatório: "subscription_summary", "coupon_usage", etc.
  reportPeriod    String    // Período: "daily", "weekly", "monthly", "yearly", "custom"
  startDate       DateTime  // Data de início do relatório
  endDate         DateTime  // Data de fim do relatório
  reportData      Json      // Dados do relatório em formato JSON
  generatedBy     String?   // ID do usuário que gerou o relatório
  
  // Campos de auditoria
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("analytics_reports")
  @@index([reportType, reportPeriod])
  @@index([startDate, endDate])
}

// ==================== ESTRUTURA DE AVA ====================

// Categorias de cursos
model CourseCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?  @db.Text
  status      Status   @default(ACTIVE)
  slug        String   @unique // URL amigável
  icon        String?  // Nome do ícone ou classe CSS
  displayOrder Int      @default(0) // Ordem de exibição
  
  // Campos de auditoria
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  
  // Relacionamento com área
  areaId      String?
  area        CourseArea? @relation(fields: [areaId], references: [id])
  
  // Relacionamento com cursos
  courses     Course[]

  @@map("course_categories")
}

// Tipos de cursos
model CourseType {
  id          String   @id @default(uuid())
  name        String   @unique // Ex: GRATUITO, PAGO, PREMIUM, etc.
  description String?  @db.Text
  status      Status   @default(ACTIVE)
  
  // Campos de auditoria
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  
  // Relacionamento com cursos
  courses     Course[]
  
  // Relacionamento com templates de certificado
  certificateTemplates CertificateTemplateCourseType[]

  @@map("course_types")
}

// Tipos de aulas
model LessonType {
  id          String   @id @default(uuid())
  name        String   @unique // VIDEO, TEXTO, QUIZ, etc.
  description String?  @db.Text
  status      Status   @default(ACTIVE)
  
  // Campos de auditoria
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  
  // Relacionamento com aulas
  lessons     Lesson[]

  @@map("lesson_types")
}

// Tipos de provas
model ExamType {
  id          String   @id @default(uuid())
  name        String   @unique // ONLINE, PRESENCIAL, etc.
  description String?  @db.Text
  status      Status   @default(ACTIVE)
  
  // Campos de auditoria
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?

  @@map("exam_types")
}

// Áreas de conhecimento (categorias principais)
model CourseArea {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?  @db.Text
  status      Status   @default(ACTIVE)
  slug        String   @unique // URL amigável
  icon        String?  // Nome do ícone ou classe CSS
  displayOrder Int      @default(0) // Ordem de exibição
  
  // Campos de auditoria
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?

  // Relacionamento com categorias
  categories  CourseCategory[]

  @@map("course_areas")
}

// ==================== MODELOS DE CURSOS ====================

// Modelo de Curso
model Course {
  id                String      @id @default(uuid())
  title             String      // Título do curso
  description       String?     @db.Text // Descrição do curso
  slug              String      @unique // URL amigável
  thumbnailUrl      String?     // Capa do curso
  
  // Relações de classificação
  coordinatorId     String
  coordinator       User        @relation("courseCoordinator", fields: [coordinatorId], references: [id])
  modalityId        String
  modality          CourseModality @relation(fields: [modalityId], references: [id])
  categoryId        String
  category          CourseCategory @relation(fields: [categoryId], references: [id])
  typeId            String
  type              CourseType @relation(fields: [typeId], references: [id])
  
  // Informações básicas
  workload          Int         // Carga horária em horas
  startDate         DateTime    // Data de início das aulas
  accessPeriod      Int         // Período de acesso em dias
  supportPeriod     Int?        // Período de suporte em dias (opcional)
  price             Decimal?    @db.Decimal(10, 2) // Preço do curso
  
  // Status do curso
  status            Status      @default(ACTIVE)
  isPublished       Boolean     @default(false)
  isHighlighted     Boolean     @default(false) // Destaque na plataforma
  videoUrl          String?     // URL do vídeo de apresentação
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  createdById       String?
  updatedById       String?
  
  // Campos para critérios de conclusão
  completionCriteria CompletionCriteria @default(MODULE_COMPLETION)
  certificateTemplateId String?
  certificateTemplate CertificateTemplate? @relation(fields: [certificateTemplateId], references: [id])
  minAttendanceForCertificate Int? // % mínimo de presença para certificado
  minGradeForCertificate Decimal? @db.Decimal(5, 2) // Nota mínima para certificado
  requiresInternship Boolean @default(false) // Se requer estágio
  internshipHours   Int?    // Horas de estágio necessárias
  customCertificateRequirements String? @db.Text // Requisitos personalizados
  
  // Relacionamentos
  professors        CourseProfessor[] // Professores do curso
  modules           CourseModule[] // Módulos do curso
  enrollments       Enrollment[] // Matrículas de alunos
  products          CourseProduct[] // Produtos vinculados
  questionBanks     QuestionBank[] // Bancos de questões
  exams             Exam[] // Provas
  studentGrades     StudentGrade[] // Notas dos alunos

  @@map("courses")
  @@index([categoryId])
  @@index([typeId])
  @@index([modalityId])
  @@index([status])
}

// Relacionamento entre curso e professor/colaborador
model CourseProfessor {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  courseId          String
  course            Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  professorId       String
  professor         User        @relation(fields: [professorId], references: [id])
  
  // Tipo de colaborador
  collaboratorType  CollaboratorType @default(PROFESSOR)
  isMain            Boolean     @default(false)
  
  // Estatísticas
  associatedLessons Int         @default(0)
  associatedModules Int         @default(0)
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@unique([courseId, professorId])
  @@map("course_professors")
}

// Relacionamento entre curso e produto
model CourseProduct {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  courseId          String
  course            Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  
  // Informações do produto
  name              String
  description       String?     @db.Text
  type              ProductType // CURSO, COMBO, ASSINATURA
  status            Status      @default(ACTIVE)
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@map("course_products")
}

// Modelo de modalidade de curso
model CourseModality {
  id                String      @id @default(uuid())
  name              String      @unique // ONLINE, PRESENCIAL, HIBRIDO, LIVE
  description       String?     @db.Text
  status            Status      @default(ACTIVE)
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  // Relacionamentos
  courses           Course[]
  certificateTemplates CertificateTemplateCourseType[]
  
  @@map("course_modalities")
}

// Modelo de módulo de curso
model CourseModule {
  id                String      @id @default(uuid())
  title             String
  description       String?     @db.Text
  order             Int         // Ordem de exibição
  
  // Relacionamento com curso
  courseId          String
  course            Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  
  // Professor responsável
  professorId       String?
  
  // Controle de acesso
  isRequired        Boolean     @default(false)  // Se o módulo é requisito
  releaseType       ReleaseType @default(IMMEDIATE) // Tipo de liberação
  releaseDate       DateTime?   // Data de liberação fixa
  releaseDays       Int?        // Dias após inscrição para liberar
  accessExpiration  Int?        // Dias para expirar o acesso após conclusão
  
  // Status e metadados
  status            Status      @default(ACTIVE)
  workload          Int?        // Em minutos
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  createdById       String?
  updatedById       String?
  
  // Relacionamentos
  lessons           Lesson[]
  exams             Exam[]
  
  @@unique([courseId, order])
  @@map("course_modules")
}

// Modelo de aula
model Lesson {
  id                String        @id @default(uuid())
  title             String
  description       String?       @db.Text
  order             Int           // Ordem de exibição
  duration          Int?          // Duração em minutos
  
  // Relacionamentos
  moduleId          String
  module            CourseModule  @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  professorId       String
  professor         User          @relation(fields: [professorId], references: [id])
  typeId            String
  type              LessonType    @relation(fields: [typeId], references: [id])
  
  // Tipo e conteúdo
  contentType       ContentType   // Tipo específico de conteúdo
  content           Json?         // Conteúdo estruturado baseado no tipo
  videoUrl          String?       // URL do vídeo (para tipo VIDEO)
  textContent       String?       @db.Text // Conteúdo em texto
  attachments       Json?         // Lista de anexos
  liveDate          DateTime?     // Data da aula ao vivo
  liveUrl           String?       // URL da transmissão
  liveKey           String?       // Chave de transmissão
  
  // Controle de acesso
  isRequired        Boolean       @default(false) // Se é uma aula requisito
  isDemonstration   Boolean       @default(false) // Se é uma aula demonstrativa
  releaseType       ReleaseType   @default(IMMEDIATE) // Como a aula é liberada
  releaseDate       DateTime?     // Data específica para liberação
  releaseDays       Int?          // Dias para liberar após aula anterior
  requiredTime      Int?          // Tempo mínimo de permanência
  maxViews          Int?          // Número máximo de visualizações
  pauseCount        Int?          // Número de pausas durante o vídeo
  showIdentification Boolean      @default(false) // Mostrar identificação como marca d'água
  
  // Status e configurações
  status            Status        @default(ACTIVE) // Status geral
  publishStatus     PublishStatus @default(DRAFT) // Status de publicação
  notifyStudents    Boolean       @default(false) // Notificar alunos
  
  // Campos de auditoria
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  createdById       String?
  updatedById       String?
  
  // Relacionamentos
  completedBy       CompletedLesson[]
  files             LessonFile[]
  examQuestions     ExamQuestion[]
  questionBankId    String?
  questionBank      QuestionBank? @relation(fields: [questionBankId], references: [id])
  notifications     LessonNotification[]

  @@map("lessons")
  @@unique([moduleId, order])
}

// Modelo de arquivo da aula
model LessonFile {
  id                String      @id @default(uuid())
  
  // Relacionamento com aula
  lessonId          String
  lesson            Lesson      @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  
  // Informações do arquivo
  filename          String
  originalName      String
  mimeType          String
  size              Int         // Tamanho em bytes
  url               String      // URL do arquivo
  pages             Int?        // Número de páginas (para PDFs)
  downloads         Int         @default(0) // Contador de downloads
  
  // Status
  status            Status      @default(ACTIVE)
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@map("lesson_files")
}

// Modelo de aula concluída
model CompletedLesson {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  enrollmentId      String
  enrollment        Enrollment  @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  lessonId          String
  lesson            Lesson      @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  
  // Informações de conclusão
  completedAt       DateTime    @default(now())
  timeSpent         Int?        // Tempo gasto em segundos
  viewCount         Int         @default(1) // Número de visualizações
  lastViewAt        DateTime    @default(now()) // Última visualização
  progress          Int         @default(100) // Progresso em porcentagem
  score             Int?        // Pontuação obtida (se aplicável)
  
  @@unique([enrollmentId, lessonId])
  @@map("completed_lessons")
}

// Modelo de matrícula
model Enrollment {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  userId            String
  user              User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  courseId          String
  course            Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  
  // Datas e informações de acesso
  enrollmentDate    DateTime    @default(now())
  expirationDate    DateTime    // Data de expiração do acesso
  supportExpiration DateTime?   // Data de expiração do suporte
  
  // Status e progresso
  status            EnrollmentStatus @default(ACTIVE)
  progress          Int         @default(0) // Progresso em percentual
  lastAccess        DateTime?   // Último acesso ao curso
  completedLessons  Int         @default(0) // Número de aulas concluídas
  totalLessons      Int         @default(0) // Total de aulas do curso
  
  // Dados financeiros
  paymentId         String?     // ID do pagamento relacionado
  price             Decimal?    @db.Decimal(10, 2) // Preço pago
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  // Relacionamentos
  completedLessonsRel CompletedLesson[]
  certificates      Certificate[]
  
  @@unique([userId, courseId])
  @@map("enrollments")
  @@index([status])
}

// ==================== MODELOS DE AVALIAÇÃO ====================

// Modelo para questões de exame/avaliação
model ExamQuestion {
  id                String      @id @default(uuid())
  lessonId          String
  lesson            Lesson      @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  
  question          String      @db.Text
  type              String      // multiple_choice, essay, true_false, etc.
  options           Json?       // Para questões de múltipla escolha
  correctAnswer     String?     // Resposta correta ou gabarito
  points            Int         @default(1) // Pontuação da questão
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  // Relacionamentos
  answers           ExamAnswer[]
  examRelations     ExamQuestionRelation[]
  attemptAnswers    ExamAttemptAnswer[]
  
  @@map("exam_questions")
}

// Modelo para respostas às questões
model ExamAnswer {
  id                String      @id @default(uuid())
  
  questionId        String
  question          ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  userId            String
  user              User        @relation(fields: [userId], references: [id])
  userAnswer        String      @db.Text
  isCorrect         Boolean?    // Nulo se ainda não corrigido
  score             Int?        // Pontuação obtida
  
  // Campos de auditoria
  submittedAt       DateTime    @default(now())
  gradedAt          DateTime?   // Quando foi corrigida
  
  @@map("exam_answers")
  @@unique([questionId, userId])
}

// Modelo para templates de certificado
model CertificateTemplate {
  id                String    @id @default(uuid())
  title             String
  description       String?   @db.Text
  
  // Configurações visuais
  backgroundImageUrl String?
  width             Int       @default(800)  // Largura em pixels
  height            Int       @default(600)  // Altura em pixels
  templateContent   String    @db.Text       // Template em XML ou HTML
  orientation       String    @default("landscape") // landscape ou portrait
  
  // Regras para emissão
  requiredCompletion CompletionCriteria @default(MODULE_COMPLETION)
  customRequirements String?   @db.Text  // Requisitos personalizados
  minAttendancePercentage Int? // % mínimo de presença
  minGrade          Decimal?  @db.Decimal(5, 2) // Nota mínima
  
  // Campos dinâmicos e variáveis
  availableFields   Json      // Campos disponíveis no template
  
  // Status do template
  isDefault         Boolean   @default(false) // Se é o template padrão
  status            Status    @default(ACTIVE)
  
  // Relacionamentos
  certificates      Certificate[]
  courses           Course[]
  courseTypes       CertificateTemplateCourseType[]
  
  // Auditoria
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  createdById       String
  createdBy         User      @relation(fields: [createdById], references: [id])
  updatedById       String?
  updatedBy         User?     @relation("certificateTemplateUpdater", fields: [updatedById], references: [id])

  @@map("certificate_templates")
}

// Relação entre template e tipos de curso
model CertificateTemplateCourseType {
  id                String    @id @default(uuid())
  
  // Relacionamentos
  templateId        String
  template          CertificateTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  courseTypeId      String
  courseType        CourseType @relation(fields: [courseTypeId], references: [id], onDelete: Cascade)
  modalityId        String?
  modality          CourseModality? @relation(fields: [modalityId], references: [id])
  
  @@unique([templateId, courseTypeId, modalityId])
  @@map("certificate_template_course_types")
}

// Modelo para certificados
model Certificate {
  id                String      @id @default(uuid())
  
  enrollmentId      String
  enrollment        Enrollment  @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  
  // Template
  templateId        String?
  template          CertificateTemplate? @relation(fields: [templateId], references: [id])
  
  // Status e identificação
  status            CertificateStatus @default(PENDING)
  certificateCode   String      @unique // Código único do certificado
  certificateUrl    String?     // URL para download do certificado
  completionDate    DateTime    // Data de conclusão
  issueDate         DateTime?   // Data de emissão
  expirationDate    DateTime?   // Data de expiração
  
  // Metadados
  finalGrade        Decimal?    @db.Decimal(5, 2) // Nota final
  attendancePercentage Int?     // Percentual de presença
  internshipCompleted Boolean?  // Se completou estágio
  internshipHours   Int?        // Horas de estágio realizadas
  completionCriteriaMet String? @db.Text // Como os critérios foram atendidos
  
  // Emissor
  issuedById        String?
  issuedBy          User?       @relation("certificateIssuer", fields: [issuedById], references: [id])
  
  // Assinaturas
  signatures        Json?       // Lista de assinaturas
  
  // Auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@map("certificates")
}

// ==================== BANCO DE QUESTÕES ====================

// Modelo para banco de questões
model QuestionBank {
  id                String      @id @default(uuid())
  title             String      // Título do banco de questões 
  description       String?     @db.Text
  status            Status      @default(ACTIVE)
  
  // Relacionamento com curso (opcional)
  courseId          String?
  course            Course?     @relation(fields: [courseId], references: [id])
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  createdById       String
  createdBy         User        @relation("questionBankCreator", fields: [createdById], references: [id])
  updatedById       String?
  updatedBy         User?       @relation("questionBankUpdater", fields: [updatedById], references: [id])
  
  // Relacionamentos
  questions         Question[]
  lessons           Lesson[]

  @@map("question_banks")
  @@index([courseId])
  @@index([status])
}

// Modelo para questão
model Question {
  id                String          @id @default(uuid())
  text              String          @db.Text  // Texto da questão
  type              QuestionType    // Tipo de questão
  difficultyLevel   DifficultyLevel @default(MEDIO)
  points            Int             @default(1) // Pontuação da questão
  status            Status          @default(ACTIVE)
  order             Int?            // Ordem da questão no banco
  
  // Conteúdo específico baseado no tipo
  options           Json?           // Opções para múltipla escolha/seleção
  correctAnswer     Json?           // Resposta(s) correta(s)
  solution          String?         @db.Text  // Explicação da resposta
  
  // Metadados e configuração
  tags              String?         // Tags para categorização
  timeLimit         Int?            // Tempo limite em segundos
  shuffleOptions    Boolean         @default(false) // Embaralhar opções
  
  // Relacionamento com banco de questões
  questionBankId    String
  questionBank      QuestionBank    @relation(fields: [questionBankId], references: [id], onDelete: Cascade)
  
  // Campos de auditoria
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  createdById       String
  createdBy         User            @relation("questionCreator", fields: [createdById], references: [id])
  updatedById       String?
  updatedBy         User?           @relation("questionUpdater", fields: [updatedById], references: [id])
  
  // Relacionamentos
  answers           QuestionAnswer[]
  examRelations     ExamQuestionRelation[]
  attemptAnswers    ExamAttemptAnswer[]

  @@map("questions")
  @@index([questionBankId])
  @@index([type])
  @@index([status])
  @@index([difficultyLevel])
}

// Modelo para respostas dos alunos às questões
model QuestionAnswer {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  questionId        String
  question          Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  userId            String
  user              User        @relation(fields: [userId], references: [id])
  
  // Dados da resposta
  answer            Json        // Resposta do aluno
  isCorrect         Boolean?    // Se a resposta está correta
  score             Int?        // Pontuação obtida
  attemptTime       Int?        // Tempo gasto em segundos
  
  // Avaliação (para questões dissertativas)
  feedback          String?     @db.Text  // Feedback do professor
  evaluatedAt       DateTime?   // Data da avaliação
  evaluatedById     String?     // ID do professor que avaliou
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  
  @@map("question_answers")
  @@unique([questionId, userId])
  @@index([isCorrect])
}

// Modelo para provas
model Exam {
  id                String        @id @default(uuid())
  title             String        // Título da prova
  description       String?       @db.Text
  weight            Int           @default(1)  // Peso da prova
  passingPercentage Int           @default(60) // Porcentagem mínima para aprovação
  duration          Int?          // Duração em minutos
  trackDispersion   Boolean       @default(false) // Contabilizar dispersão
  notifyStudents    Boolean       @default(false) // Notificar alunos
  
  // Configurações de liberação
  releaseType       ExamReleaseType @default(IMMEDIATELY)
  releaseDate       DateTime?     // Data específica para liberação
  releaseAfterDays  Int?          // Dias após concluir aula anterior
  
  // Configurações de requisito
  isRequired        Boolean       @default(true) // Prova é requisito para avançar
  
  // Configurações de tentativas
  maxAttempts       Int           @default(1)  // Número máximo de tentativas
  allowMultipleAttempts Boolean   @default(false) // Permitir múltiplas tentativas
  showAnswerAfterAttempt Boolean  @default(false) // Mostrar gabarito após tentativa
  attemptCooldownHours Int?       // Horas para liberar nova tentativa
  attemptCooldownDays Int?        // Dias para liberar nova tentativa
  
  // Configurações de questões
  questionOrder     QuestionOrder @default(SEQUENTIAL)
  totalQuestions    Int           @default(0) // Total de questões na prova
  
  // Relacionamentos
  courseId          String
  course            Course        @relation(fields: [courseId], references: [id], onDelete: Cascade)
  moduleId          String?
  module            CourseModule? @relation(fields: [moduleId], references: [id])
  
  // Campos de auditoria
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  createdById       String
  createdBy         User          @relation("examCreator", fields: [createdById], references: [id])
  updatedById       String?
  updatedBy         User?         @relation("examUpdater", fields: [updatedById], references: [id])
  
  // Relacionamentos
  questions         ExamQuestionRelation[]
  studentAttempts   ExamAttempt[]
  studentGrades     StudentGrade[]

  @@map("exams")
  @@index([courseId])
  @@index([moduleId])
}

// Relação entre exame e questões
model ExamQuestionRelation {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  examId            String
  exam              Exam        @relation(fields: [examId], references: [id], onDelete: Cascade)
  
  // A questão pode vir de:
  questionId        String?
  question          Question?   @relation(fields: [questionId], references: [id])
  examQuestionId    String?
  examQuestion      ExamQuestion? @relation(fields: [examQuestionId], references: [id])
  
  // Metadados da questão
  order             Int         // Ordem da questão na prova
  points            Int         @default(1) // Pontuação específica
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  
  @@unique([examId, questionId])
  @@unique([examId, examQuestionId])
  @@map("exam_question_relations")
}

// Modelo para tentativas de prova dos alunos
model ExamAttempt {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  examId            String
  exam              Exam        @relation(fields: [examId], references: [id], onDelete: Cascade)
  userId            String
  user              User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Informações da tentativa
  startedAt         DateTime    @default(now())
  completedAt       DateTime?
  isCompleted       Boolean     @default(false)
  score             Decimal?    @db.Decimal(5, 2) // Pontuação obtida
  percentageScore   Decimal?    @db.Decimal(5, 2) // Porcentagem de acerto
  duration          Int?        // Tempo gasto em segundos
  attempt           Int         @default(1) // Número da tentativa
  passed            Boolean?    // Se passou na prova
  
  // Monitoramento de comportamento
  dispersionCount   Int         @default(0) // Contagem de saídas
  dispersionTime    Int         @default(0) // Tempo total fora da prova
  dispersionEvents  Json?       // Eventos de dispersão
  
  // Campos de auditoria
  createdAt         DateTime    @default(now())
  
  // Relacionamentos
  answers           ExamAttemptAnswer[]
  grade             StudentGrade?
  
  @@unique([examId, userId, attempt])
  @@map("exam_attempts")
  @@index([userId])
  @@index([examId])
  @@index([passed])
}

// Modelo para respostas da tentativa
model ExamAttemptAnswer {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  attemptId         String
  attempt           ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  questionId        String?
  question          Question?   @relation(fields: [questionId], references: [id])
  examQuestionId    String?
  examQuestion      ExamQuestion? @relation(fields: [examQuestionId], references: [id])
  
  // Relação com o usuário
  userId            String
  user              User        @relation(fields: [userId], references: [id])
  
  // Dados da resposta
  answer            Json        // Resposta do aluno
  isCorrect         Boolean?    // Se a resposta está correta
  score             Decimal?    @db.Decimal(5, 2) // Pontuação obtida
  
  // Avaliação (para questões dissertativas)
  feedback          String?     @db.Text  // Feedback do professor
  evaluatedAt       DateTime?   // Data da avaliação
  evaluatedById     String?     // ID do professor que avaliou
  
  // Campos de auditoria
  answeredAt        DateTime    @default(now())
  
  @@unique([attemptId, questionId])
  @@unique([attemptId, examQuestionId])
  @@map("exam_attempt_answers")
}

// Modelo para boletim/notas dos alunos
model StudentGrade {
  id                String      @id @default(uuid())
  
  // Relacionamentos
  userId            String
  user              User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  courseId          String
  course            Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  examId            String?
  exam              Exam?       @relation(fields: [examId], references: [id])
  
  // Relacionamento com tentativa específica
  attemptId         String?     @unique
  attempt           ExamAttempt? @relation(fields: [attemptId], references: [id])
  
  // Informações da nota
  score             Decimal     @db.Decimal(5, 2) // Nota obtida
  maxScore          Decimal     @db.Decimal(5, 2) // Nota máxima possível
  weight            Int         @default(1) // Peso da avaliação
  passingScore      Decimal?    @db.Decimal(5, 2) // Nota para aprovação
  passed            Boolean     // Se passou nesta avaliação
  
  // Dados adicionais
  gradedAt          DateTime    @default(now())
  comment           String?     @db.Text
  
  @@unique([userId, courseId, examId])
  @@map("student_grades")
  @@index([userId, courseId])
}

// ==================== NOTIFICAÇÕES ====================

// Modelo para notificações de aulas
model LessonNotification {
  id                String    @id @default(uuid())
  
  // Relacionamento com a aula
  lessonId          String
  lesson            Lesson    @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  
  // Conteúdo da notificação
  title             String
  message           String    @db.Text
  
  // Status da notificação
  isSent            Boolean   @default(false)
  sentAt            DateTime?
  errorMessage      String?   @db.Text
  
  // Métricas
  viewCount         Int       @default(0)
  clickCount        Int       @default(0)
  
  // Campos de auditoria
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relacionamento com usuários notificados
  recipients        UserNotification[]

  @@map("lesson_notifications")
}

// Relacionamento entre notificação e usuário
model UserNotification {
  id                String    @id @default(uuid())
  
  // Relacionamentos
  notificationId    String
  notification      LessonNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Status da notificação para este usuário
  isRead            Boolean   @default(false)
  readAt            DateTime?
  isClicked         Boolean   @default(false)
  clickedAt         DateTime?
  
  // Campo de auditoria
  createdAt         DateTime  @default(now())

  @@unique([notificationId, userId])
  @@map("user_notifications")
}

// ==================== SISTEMA DE VAGAS E RECRUTAMENTO ====================

// Modelo para vagas
model JobOffer {
  id                String          @id @default(uuid())
  title             String          // Título/Nome da vaga
  description       String          @db.Text // Descrição detalhada da vaga
  location          String          // Localização da vaga
  experienceLevel   ExperienceLevel // Nível de experiência requerido
  hiringType        HiringType      // Tipo de contratação
  isConfidential    Boolean         @default(false) // Nome da empresa oculto
  
  // Datas e prazos
  startDate         DateTime        // Data de início da publicação
  endDate           DateTime        // Data de término da publicação
  
  // Limites e contadores
  maxApplications   Int?            // Limite de candidaturas
  applicationCount  Int             @default(0) // Contador de candidaturas
  
  // Status e controle
  status            JobStatus       @default(DRAFT) // Status atual da vaga
  rejectionReason   String?         @db.Text // Motivo da rejeição
  
  // Relacionamentos
  companyId         String
  company           User            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reviewerId        String?
  reviewer          User?           @relation("jobReviewer", fields: [reviewerId], references: [id])
  revisions         JobRevision[]
  applications      JobApplication[]
  
  // Campos de auditoria
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@map("job_offers")
  @@index([companyId])
  @@index([status])
  @@index([experienceLevel])
  @@index([hiringType])
}

// Histórico de revisões de vagas
model JobRevision {
  id                String    @id @default(uuid())
  
  // Relacionamentos
  jobOfferId        String
  jobOffer          JobOffer  @relation(fields: [jobOfferId], references: [id], onDelete: Cascade)
  revisorId         String
  revisor           User      @relation(fields: [revisorId], references: [id])
  
  // Dados da revisão
  changesJson       Json      // Alterações realizadas em formato JSON
  
  // Campos de auditoria
  createdAt         DateTime  @default(now())

  @@map("job_revisions")
  @@index([jobOfferId])
}

// Modelo para currículos de alunos
model Resume {
  id                String    @id @default(uuid())
  
  // Relacionamento com o usuário
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Dados do currículo
  professionalSummary String?  @db.Text // Resumo profissional
  skillsJson        Json?     // Habilidades em formato JSON
  
  // Documentos
  resumeUrl         String?   // URL do currículo em PDF/DOCX
  resumeFilename    String?   // Nome do arquivo
  
  // Visibilidade
  isPublic          Boolean   @default(false) // Se o currículo é público
  
  // Campos de auditoria
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relacionamentos
  experiences       WorkExperience[]
  education         Education[]
  applications      JobApplication[]

  @@map("resumes")
}

// Modelo para experiências profissionais
model WorkExperience {
  id                String    @id @default(uuid())
  
  // Relacionamento com o currículo
  resumeId          String
  resume            Resume    @relation(fields: [resumeId], references: [id], onDelete: Cascade)
  
  // Dados da experiência
  companyName       String
  position          String
  startDate         DateTime
  endDate           DateTime?
  currentJob        Boolean   @default(false)
  description       String?   @db.Text
  
  // Campos de auditoria
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("work_experiences")
  @@index([resumeId])
}

// Modelo para formação acadêmica
model Education {
  id                String    @id @default(uuid())
  
  // Relacionamento com o currículo
  resumeId          String
  resume            Resume    @relation(fields: [resumeId], references: [id], onDelete: Cascade)
  
  // Dados da formação
  institution       String
  degree            String
  fieldOfStudy      String?
  startDate         DateTime
  endDate           DateTime?
  currentlyStudying Boolean   @default(false)
  description       String?   @db.Text
  
  // Campos de auditoria
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("education")
  @@index([resumeId])
}

// Modelo para candidaturas
model JobApplication {
  id                String    @id @default(uuid())
  
  // Relacionamentos
  jobOfferId        String
  jobOffer          JobOffer  @relation(fields: [jobOfferId], references: [id], onDelete: Cascade)
  userId            String    // Candidato
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  resumeId          String
  resume            Resume    @relation(fields: [resumeId], references: [id], onDelete: Restrict)
  
  // Status e acompanhamento
  status            ApplicationStatus @default(SUBMITTED)
  notes             String?   @db.Text // Notas internas
  
  // Campos de auditoria
  appliedAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relacionamentos
  interviews        JobInterview[]
  statusHistory     ApplicationStatusHistory[]

  @@unique([jobOfferId, userId]) // Um usuário só pode se candidatar uma vez
  @@map("job_applications")
  @@index([userId])
  @@index([jobOfferId])
  @@index([status])
}

// Histórico de mudanças de status
model ApplicationStatusHistory {
  id                String    @id @default(uuid())
  
  // Relacionamentos
  applicationId     String
  application       JobApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  changedById       String
  changedBy         User      @relation(fields: [changedById], references: [id])
  
  // Dados da alteração
  previousStatus    ApplicationStatus
  newStatus         ApplicationStatus
  notes             String?   @db.Text
  
  // Campos de auditoria
  changedAt         DateTime  @default(now())

  @@map("application_status_history")
  @@index([applicationId])
}

// Modelo para entrevistas/reuniões
model JobInterview {
  id                String    @id @default(uuid())
  
  // Relacionamento com a candidatura
  applicationId     String
  application       JobApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  
  // Dados da entrevista
  scheduleDateTime  DateTime
  duration          Int       // Duração em minutos
  location          String?   // Local físico (se aplicável)
  meetingUrl        String?   // URL da reunião virtual
  meetingType       String?   // Tipo de reunião (Meet, Zoom, etc)
  notes             String?   @db.Text
  
  // Status
  isCompleted       Boolean   @default(false)
  feedbackNotes     String?   @db.Text // Feedback após a entrevista
  
  // Campos de auditoria
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  createdById       String
  createdBy         User      @relation(fields: [createdById], references: [id])

  @@map("job_interviews")
  @@index([applicationId])
  @@index([scheduleDateTime])
}