/**
 * Script de deploy otimizado para o ambiente Render
 * Resolve problemas espec√≠ficos de caminho do Prisma Client
 */
const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

// Cores para melhor visualiza√ß√£o no console
const colors = {
  reset: "\x1b[0m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  red: "\x1b[31m",
  blue: "\x1b[34m",
  bold: "\x1b[1m",
};

// Imprime cabe√ßalho do script
console.log(`
${colors.bold}${colors.blue}====================================================
       SCRIPT DE DEPLOY PARA RENDER - API PROJETO
====================================================
${colors.reset}
`);

/**
 * Executa um comando com tratamento de erros
 * @param {string} command Comando a ser executado
 * @param {string} description Descri√ß√£o do comando
 * @param {boolean} critical Se o comando √© cr√≠tico para o deploy
 * @returns {boolean} Se o comando foi bem-sucedido
 */
function executeCommand(command, description, critical = true) {
  console.log(`${colors.blue}‚û§ ${description}...${colors.reset}`);

  try {
    // Executa o comando e retorna a sa√≠da
    const output = execSync(command, { stdio: "pipe" }).toString();
    console.log(
      `${colors.green}‚úì ${description} conclu√≠do com sucesso${colors.reset}`
    );

    // Imprime a sa√≠da do comando de forma limitada (evita logs muito grandes)
    if (output && output.length > 0) {
      // Limita a sa√≠da a 20 linhas
      const limitedOutput = output.split("\n").slice(0, 20).join("\n");
      console.log(`${colors.bold}Sa√≠da:${colors.reset}\n${limitedOutput}`);

      if (output.split("\n").length > 20) {
        console.log(`${colors.yellow}[Sa√≠da truncada...]${colors.reset}`);
      }
    }

    return true;
  } catch (error) {
    console.error(
      `${colors.red}‚úó Erro ao executar ${description}${colors.reset}`
    );
    console.error(`${colors.red}${error.message}${colors.reset}`);

    if (error.stdout) {
      console.error(
        `${colors.yellow}Sa√≠da:${colors.reset}\n${error.stdout.toString()}`
      );
    }

    if (error.stderr) {
      console.error(
        `${colors.red}Erro:${colors.reset}\n${error.stderr.toString()}`
      );
    }

    // Se o comando for cr√≠tico, encerra o processo
    if (critical) {
      console.error(
        `${colors.red}${colors.bold}Falha cr√≠tica, abortando deploy!${colors.reset}`
      );
      process.exit(1);
    }

    return false;
  }
}

/**
 * Criar ou modificar um arquivo com conte√∫do espec√≠fico
 * @param {string} filePath Caminho do arquivo
 * @param {string} content Conte√∫do do arquivo
 * @param {string} description Descri√ß√£o da opera√ß√£o
 */
function createOrUpdateFile(filePath, content, description) {
  try {
    console.log(`${colors.blue}‚û§ ${description}...${colors.reset}`);

    // Certifica-se de que o diret√≥rio existe
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Escreve o arquivo
    fs.writeFileSync(filePath, content);
    console.log(
      `${colors.green}‚úì ${description} conclu√≠do com sucesso${colors.reset}`
    );

    return true;
  } catch (error) {
    console.error(`${colors.red}‚úó Erro ao ${description}${colors.reset}`);
    console.error(`${colors.red}${error.message}${colors.reset}`);
    return false;
  }
}

/**
 * Verifica se determinadas vari√°veis de ambiente est√£o definidas
 * @param {string[]} requiredEnvVars Lista de vari√°veis de ambiente necess√°rias
 */
function checkEnvironmentVariables(requiredEnvVars) {
  console.log(
    `${colors.blue}‚û§ Verificando vari√°veis de ambiente...${colors.reset}`
  );

  const missingVars = requiredEnvVars.filter(
    (varName) => !process.env[varName]
  );

  if (missingVars.length > 0) {
    console.warn(
      `${colors.yellow}‚ö†Ô∏è Vari√°veis de ambiente ausentes: ${missingVars.join(
        ", "
      )}${colors.reset}`
    );
    console.warn(
      `${colors.yellow}Certifique-se de configur√°-las no painel do Render!${colors.reset}`
    );
  } else {
    console.log(
      `${colors.green}‚úì Todas as vari√°veis de ambiente necess√°rias est√£o definidas${colors.reset}`
    );
  }
}

/**
 * Cria um arquivo Prisma loader customizado para o Render
 */
function createCustomPrismaLoader() {
  const loaderContent = `/**
 * Loader personalizado para o Prisma Client no ambiente Render com pnpm
 */

// Caminhos poss√≠veis para o Prisma Client em diferentes ambientes
const possiblePaths = [
  // Caminhos padr√£o
  '@prisma/client',
  '../../node_modules/@prisma/client',
  '../../../node_modules/@prisma/client',
  
  // Caminhos espec√≠ficos do Render
  '/opt/render/project/src/node_modules/@prisma/client',
  '/opt/render/project/src/node_modules/.prisma/client',
  
  // Caminhos espec√≠ficos para pnpm no Render
  '/opt/render/project/src/node_modules/.pnpm/@prisma+client@*/node_modules/@prisma/client',
  '/opt/render/project/src/node_modules/.pnpm/@prisma+client@*/node_modules/.prisma/client'
];

// Inicializa as exporta√ß√µes padr√£o
let prismaExports;

// Tenta carregar o Prisma Client de cada caminho poss√≠vel
for (const modulePath of possiblePaths) {
  try {
    console.log(\`Tentando carregar Prisma Client de: \${modulePath}\`);
    prismaExports = require(modulePath);
    console.log(\`‚úÖ Prisma Client carregado com sucesso de: \${modulePath}\`);
    
    // Se encontrou, exporta e para a busca
    module.exports = prismaExports;
    break;
  } catch (err) {
    // Silencia erros de 'module not found' mas loga outros tipos de erro
    if (err.code !== 'MODULE_NOT_FOUND') {
      console.error(\`‚ùå Erro ao carregar \${modulePath}: \${err.message}\`);
    }
  }
}

// Se nenhum caminho funcionou, procura dinamicamente
if (!prismaExports) {
  try {
    console.log('üîç Tentando localizar @prisma/client dinamicamente...');
    const { execSync } = require('child_process');
    
    // Tenta encontrar os caminhos instalados do Prisma Client
    const findCommand = 'find /opt/render/project/src/node_modules -path "*prisma/client/index.js" | head -n 1';
    const clientPath = execSync(findCommand).toString().trim();
    
    if (clientPath && clientPath.length > 0) {
      console.log(\`üîç Encontrado caminho: \${clientPath}\`);
      prismaExports = require(clientPath);
      console.log('‚úÖ Prisma Client carregado dinamicamente com sucesso');
      module.exports = prismaExports;
    } else {
      throw new Error('N√£o foi poss√≠vel encontrar o caminho do Prisma Client');
    }
  } catch (dynamicError) {
    console.error(\`‚ùå Erro na busca din√¢mica: \${dynamicError.message}\`);
    
    // Cria uma implementa√ß√£o de stub como √∫ltimo recurso
    console.warn('‚ö†Ô∏è Criando implementa√ß√£o de fallback do PrismaClient');
    
    module.exports = {
      PrismaClient: class StubPrismaClient {
        constructor() {
          console.error('‚ö†Ô∏è USANDO STUB DO PRISMA CLIENT - Conex√µes de banco n√£o funcionar√£o');
          return new Proxy({}, {
            get: function(target, prop) {
              if (prop === '$connect') {
                return async () => { 
                  console.error('‚ùå Erro: PrismaClient est√° usando implementa√ß√£o stub');
                  throw new Error('PrismaClient n√£o foi inicializado corretamente');
                };
              }
              if (prop === '$disconnect') return async () => {};
              if (prop === '$on') return () => {};
              if (prop === '$transaction') return async (fn) => fn({});
              if (prop === '$queryRaw') return async () => [];
              
              // Retorna um proxy para chamadas encadeadas
              return () => new Proxy({}, {
                get: () => () => ({}),
                apply: () => ({})
              });
            }
          });
        }
      },
      Prisma: {
        PrismaClientKnownRequestError: class PrismaClientKnownRequestError extends Error {
          constructor(message, opts = {}) {
            super(message);
            this.name = 'PrismaClientKnownRequestError';
            this.code = opts.code || 'UNKNOWN';
            this.meta = opts.meta || {};
            this.clientVersion = opts.clientVersion || 'stub';
          }
        },
        PrismaClientValidationError: class PrismaClientValidationError extends Error {
          constructor(message) {
            super(message);
            this.name = 'PrismaClientValidationError';
          }
        }
      }
    };
  }
}
`;

  // Cria o arquivo do loader
  const loaderPath = path.join(
    process.cwd(),
    "scripts",
    "prisma-render-loader.js"
  );
  createOrUpdateFile(
    loaderPath,
    loaderContent,
    "Criando loader customizado para o Prisma no Render"
  );

  // Cria um diret√≥rio para a c√≥pia do loader na pasta dist
  const distDir = path.join(process.cwd(), "dist", "scripts");
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
  }

  // Copia o loader para a pasta dist
  const distLoaderPath = path.join(distDir, "prisma-render-loader.js");
  fs.copyFileSync(loaderPath, distLoaderPath);
  console.log(
    `${colors.green}‚úì Loader customizado copiado para pasta dist com sucesso${colors.reset}`
  );
}

/**
 * Aplica patch no c√≥digo compilado para usar o loader customizado
 */
function patchCompiledCode() {
  const databaseJsPath = path.join(
    process.cwd(),
    "dist",
    "config",
    "database.js"
  );

  if (!fs.existsSync(databaseJsPath)) {
    console.error(
      `${colors.red}‚úó Arquivo database.js n√£o encontrado em dist/config!${colors.reset}`
    );
    return false;
  }

  try {
    console.log(
      `${colors.blue}‚û§ Aplicando patch no database.js...${colors.reset}`
    );

    // L√™ o conte√∫do atual
    let content = fs.readFileSync(databaseJsPath, "utf8");

    // Substitui o require do loader padr√£o pelo customizado
    content = content.replace(
      /require\(['"](\.\.\/\.\.\/scripts\/prisma-loader)['"]\)/g,
      'require("../../scripts/prisma-render-loader")'
    );

    // Escreve o conte√∫do modificado
    fs.writeFileSync(databaseJsPath, content);

    console.log(
      `${colors.green}‚úì Patch aplicado com sucesso no database.js${colors.reset}`
    );
    return true;
  } catch (error) {
    console.error(
      `${colors.red}‚úó Erro ao aplicar patch: ${error.message}${colors.reset}`
    );
    return false;
  }
}

/**
 * Verifica e configura a porta correta para o Render
 */
function configurePort() {
  // O Render espera que a aplica√ß√£o escute na porta especificada pela vari√°vel PORT
  const port = process.env.PORT || 10000;

  console.log(
    `${colors.blue}‚û§ Configurando aplica√ß√£o para usar a porta ${port}...${colors.reset}`
  );

  // Cria um arquivo .env.production com a porta configurada
  const envContent = `PORT=${port}\n`;
  createOrUpdateFile(
    path.join(process.cwd(), ".env.production"),
    envContent,
    "Criando arquivo .env.production com configura√ß√£o de porta"
  );

  return true;
}

// Executa as etapas de deploy em sequ√™ncia
async function deploy() {
  console.log(
    `${colors.bold}${colors.blue}Iniciando deploy no Render...${colors.reset}`
  );

  // Verifica vari√°veis de ambiente
  checkEnvironmentVariables(["DATABASE_URL", "JWT_SECRET"]);

  // Configura a porta correta
  configurePort();

  // Limpa a pasta dist
  executeCommand("rm -rf dist", "Limpando pasta dist");

  // Cria o loader personalizado do Prisma para o Render
  createCustomPrismaLoader();

  // Gera o Prisma Client
  executeCommand("npx prisma generate", "Gerando Prisma Client");

  // Compila o TypeScript
  executeCommand("npx tsc", "Compilando TypeScript");

  // Processa alias de importa√ß√£o (se aplic√°vel)
  executeCommand("npx tsc-alias", "Processando alias de importa√ß√£o", false);

  // Aplica patch no c√≥digo compilado
  patchCompiledCode();

  console.log(
    `${colors.bold}${colors.green}Deploy preparado com sucesso!${colors.reset}`
  );
  console.log(
    `${colors.bold}${colors.green}A aplica√ß√£o est√° pronta para ser iniciada pelo Render.${colors.reset}`
  );
}

// Executa o deploy
deploy().catch((error) => {
  console.error(
    `${colors.red}Erro fatal durante o deploy:${colors.reset}`,
    error
  );
  process.exit(1);
});
